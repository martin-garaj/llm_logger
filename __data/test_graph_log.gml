graph [
  metadata [
    time "1717076082.424857"
  ]
  node [
    id 0
    label "CHAP_000001"
    data [
      title "1.A"
      content ""
    ]
    metadata [
      time "1717076082.425387"
      type "CHAP_"
      style "default"
    ]
  ]
  node [
    id 1
    label "NODE_000001"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variab"
    ]
    metadata [
      time "1717076082.425601"
      type "NODE_"
      column "A"
      style "decision"
      stack 0
      chapter_id "CHAP_000001"
    ]
  ]
  node [
    id 2
    label "NODE_000002"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   log                                  ##&#10;    ##------------------------------------------------------------------------##&#10;    def log(self, &#10;            column:str=&#34;other&#34;, &#10;            style:str=&#34;default&#34;, &#10;            stack:bool=False,&#10;            content:Any=None, &#10;            relates_to_node_id:NodeID=None, &#10;            relation_content:Any=None,&#10;            relation_style:str=&#34;default&#34;) -> NodeID:&#10;        &#34;&#34;&#34; Create a node in the log-graph, returns the nodes ID. &#10;            The node may be connected to previously logged node using &#10;            'relate_to' given the previous node ID (self-loops thus do not exists). &#10;&#10;        :param column: Column of the log-graph, defaults to &#34;other&#34;&#10;        :param style: Category relates to the visual style of the node, &#10;            defaults to &#34;default&#34;&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        :param relates_to: Previous node ID to create edge between nodes, &#10;            defaults to None&#10;        :param relation_content: Edge content displayed in llm_logger_app, &#10;            defaults to None&#10;        :param stack: Stack successive nodes with the same column, &#10;            defaults to False&#10;        :return: Unique Node ID.&#10;        &#34;&#34;&#34;&#10;        &#10;        # assure the columns names with leading &#38; trailing '_' &#10;        # are reserved for internal purpose only&#10;        column = column.strip('_')&#10;        &#10;        # get new node id&#10;        self.__node_counter = self.__node_counter + 1&#10;        node_id = NodeID(self.__node_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = node_id,&#10;            data=dict(&#10;                title=&#34;&#34;,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_NODE,&#10;                column = column.strip('_'),&#10;                style = style.strip('_'),&#10;                stack = stack,&#10;                chapter_id = ChapterID(self.__chapter_counter),&#10;                ),&#10;            )&#10;        &#10;        # add edge&#10;        if isinstance(relates_to_node_id, NodeID):&#10;            self._graph.add_edge(&#10;                u_of_edge=node_id,&#10;                v_of_edge=relates_to_node_id,&#10;                data=dict(&#10;                    title=&#34;&#34;,&#10;                    content=relation_content,&#10;                    ),&#10;                metadata=dict(&#10;                    time=str(self._get_timestamp()),&#10;                    type=_EDGE,&#10;                    style=relation_style.strip('_'),&#10;                    ),&#10;                )&#10;        &#10;        return node_id&#10;    &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                               new_chapter                              ##&#10;    ##------------------------------------------------------------------------##&#10;    def new_chapter(self, &#10;                    title:str,&#10;                    style:str=&#34;default&#34;, &#10;                    content:Any=None) -> None:&#10;        &#34;&#34;&#34; Create new chapter, thus partitioning the log-graph in &#10;            vertical manner.&#10;&#10;        :param title: Title of the chapter displayed in ll_logger_app.&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        &#34;&#34;&#34;&#10;        # get new node id&#10;        self.__chapter_counter = self.__chapter_counter + 1&#10;        chapter_id = ChapterID(self.__chapter_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = chapter_id,&#10;            data=dict(&#10;                title=title,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_CHAPTER,&#10;                style = style.strip('_'),&#10;                ),&#10;            )&#10;    &#10;    &#10;    ##------------------------------------------------------------------------##&#10;    ##                                  report                                ##&#10;    ##------------------------------------------------------------------------##&#10;    def report(self):&#10;        chapter_ids_with_node_ids = \&#10;            get_chapter_ids_with_node_ids(graph=self._graph)&#10;        &#10;        for chapter_id, node_ids in chapter_ids_with_node_ids.items():&#10;            print(f&#34;ChapterID = '{chapter_id}'&#34;)&#10;            for node_id in node_ids:&#10;                print(f&#34;   NodeID = '{node_id}'&#34;)&#10;        &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   save                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def save(self, &#10;            path:str=None, &#10;            filename:str=None, &#10;            format=&#34;gml&#34;, &#10;            **kwargs,&#10;        ) -> None:&#10;        &#10;        # parh&#10;        if isinstance(path, type(None)):&#10;            if isinstance(self.path, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'path' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                path = self.path&#10;        else:&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        # filename&#10;        if isinstance(filename, type(None)):&#10;            if isinstance(self.filename, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'filename' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                filename = self.filename&#10;        &#10;        def default_stringizer(value:Any) -> str:&#10;            import re&#10;            if isinstance(value, type(None)):&#10;                return &#34;&#34;&#10;            if isinstance(value, NodeID):&#10;                return str(value)&#10;            if isinstance(value, ChapterID):&#10;                return str(value)&#10;            if isinstance(value, list):&#10;                return str(value)&#10;            if isinstance(value, str):&#10;                return value&#10;            raise ValueError(&#10;                f&#34;default_stringizer undefined conversion for &#34;\&#10;                f&#34;type(value)='{type(value)}'!&#34;)&#10;            &#10;        # save&#10;        if str(format).lower() == &#34;gml&#34;:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;        elif str(format).lower() == &#34;dot&#34;:&#10;            nx.write_dot(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.dot&#34;),&#10;            )&#10;        else:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;            raise TypeError(&#10;                f&#34;Format='{format}', but valid formats=['gml', 'dot']! The graph &#34;\&#10;                f&#34;was saved as {str(pl.Path(path, str(filename)+'.gml'))} &#34;\&#10;                f&#34;to prevent data-loss.&#34;)&#10;&#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   load                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def load(self,&#10;             path_or_buffer:Any,&#10;             filename:str=None,&#10;             **kwargs,&#10;        ) -> nx.Graph: &#10;&#10;        # path or buffer&#10;        suffix = &#34;&#34;&#10;        if isinstance(path_or_buffer, io.BytesIO):&#10;            path = path_or_buffer&#10;            if not isinstance(filename, type(None)):&#10;                suffix = str(pl.Path(filename).suffix).replace(&#34;.&#34;, &#34;&#34;).lower()&#10;        else:&#10;            path = pl.Path(path_or_buffer)&#10;            suffix = str(path.suffix).replace(&#34;.&#34;, &#34;&#34;).lower()&#10;        # default format&#10;        if suffix == &#34;&#34;:&#10;            suffix = &#34;gml&#34;&#10;                &#10;        # read&#10;        if suffix == &#34;gml&#34;:&#10;            graph = nx.read_gml(&#10;                path = path,&#10;                destringizer=kwargs.get(&#34;destringizer&#34;, None),&#10;            )&#10;        elif suffix == &#34;dot&#34;:&#10;            nx.read_dot(&#10;                path = path,&#10;            )&#10;        else:&#10;            graph = nx.read_gml(&#10;                path = path,&#10;                destringizer=kwargs.get(&#34;destringizer&#34;, None),&#10;            )&#10;        &#10;        return graph&#10;    &#10;&#10;    ############################################################################&#10;    ##                                PRIVATE                                 ##&#10;    ############################################################################&#10;    def _test(self, &#10;            num_nodes:int=10, &#10;            num_chapters:int=5, &#10;            num_columns:int=3, &#10;            connectivit"
    ]
    metadata [
      time "1717076082.425769"
      type "NODE_"
      column "B"
      style "error"
      stack 1
      chapter_id "CHAP_000001"
    ]
  ]
  node [
    id 3
    label "NODE_000003"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   log                                  ##&#10;    ##------------------------------------------------------------------------##&#10;    def log(self, &#10;            column:str=&#34;other&#34;, &#10;            style:str=&#34;default&#34;, &#10;            stack:bool=False,&#10;            content:Any=None, &#10;            relates_to_node_id:NodeID=None, &#10;            relation_content:Any=None,&#10;            relation_style:str=&#34;default&#34;) -> NodeID:&#10;        &#34;&#34;&#34; Create a node in the log-graph, returns the nodes ID. &#10;            The node may be connected to previously logged node using &#10;            'relate_to' given the previous node ID (self-loops thus do not exists). &#10;&#10;        :param column: Column of the log-graph, defaults to &#34;other&#34;&#10;        :param style: Category relates to the visual style of the node, &#10;            defaults to &#34;default&#34;&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        :param relates_to: Previous node ID to create edge between nodes, &#10;            defaults to None&#10;        :param relation_content: Edge content displayed in llm_logger_app, &#10;            defaults to None&#10;        :param stack: Stack successive nodes with the same column, &#10;            defaults to False&#10;        :return: Unique Node ID.&#10;        &#34;&#34;&#34;&#10;        &#10;        # assure the columns names with leading &#38; trailing '_' &#10;        # are reserved for internal purpose only&#10;        column = column.strip('_')&#10;        &#10;        # get new node id&#10;        self.__node_counter = self.__node_counter + 1&#10;        node_id = NodeID(self.__node_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = node_id,&#10;            "
    ]
    metadata [
      time "1717076082.425934"
      type "NODE_"
      column "D"
      style "default"
      stack 1
      chapter_id "CHAP_000001"
    ]
  ]
  node [
    id 4
    label "NODE_000004"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   log      "
    ]
    metadata [
      time "1717076082.426068"
      type "NODE_"
      column "B"
      style "success"
      stack 0
      chapter_id "CHAP_000001"
    ]
  ]
  node [
    id 5
    label "NODE_000005"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   log                                  ##&#10;    ##------------------------------------------------------------------------##&#10;    def log(self, &#10;            column:str=&#34;other&#34;, &#10;            style:str=&#34;default&#34;, &#10;            stack:bool=False,&#10;            content:Any=None, &#10;            relates_to_node_id:NodeID=None, &#10;            relation_content:Any=None,&#10;            relation_style:str=&#34;default&#34;) -> NodeID:&#10;        &#34;&#34;&#34; Create a node in the log-graph, returns the nodes ID. &#10;            The node may be connected to previously logged node using &#10;            'relate_to' given the previous node ID (self-loops thus do not exists). &#10;&#10;        :param column: Column of the log-graph, defaults to &#34;other&#34;&#10;        :param style: Category relates to the visual style of the node, &#10;            defaults to &#34;default&#34;&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        :param relates_to: Previous node ID to create edge between nodes, &#10;            defaults to None&#10;        :param relation_content: Edge content displayed in llm_logger_app, &#10;            defaults to None&#10;        :param stack: Stack successive nodes with the same column, &#10;            defaults to False&#10;        :return: Unique Node ID.&#10;        &#34;&#34;&#34;&#10;        &#10;        # assure the columns names with leading &#38; trailing '_' &#10;        # are reserved for internal purpose only&#10;        column = column.strip('_')&#10;        &#10;        # get new node id&#10;        self.__node_counter = self.__node_counter + 1&#10;        node_id = NodeID(self.__node_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = node_id,&#10;            data=dict(&#10;                title=&#34;&#34;,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self"
    ]
    metadata [
      time "1717076082.42622"
      type "NODE_"
      column "A"
      style "error"
      stack 1
      chapter_id "CHAP_000001"
    ]
  ]
  node [
    id 6
    label "NODE_000006"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   log                                  ##&#10;    ##------------------------------------------------------------------------##&#10;    def log(self, &#10;            column:str=&#34;other&#34;, &#10;            style:str=&#34;default&#34;, &#10;            stack:bool=False,&#10;            content:Any=None, &#10;            relates_to_node_id:NodeID=None, &#10;            relation_content:Any=None,&#10;            relation_style:str=&#34;default&#34;) -> NodeID:&#10;        &#34;&#34;&#34; Create a node in the log-graph, returns the nodes ID. &#10;            The node may be connected to previously logged node using &#10;            'relate_to' given the previous node ID (self-loops thus do not exists). &#10;&#10;        :param column: Column of the log-graph, defaults to &#34;other&#34;&#10;        :param style: Category relates to the visual style of the node, &#10;            defaults to &#34;default&#34;&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        :param relates_to: Previous node ID to create edge between nodes, &#10;            defaults to None&#10;        :param relation_content: Edge content displayed in llm_logger_app, &#10;            defaults to None&#10;        :param stack: Stack successive nodes with the same column, &#10;            defaults to False&#10;        :return: Unique Node ID.&#10;        &#34;&#34;&#34;&#10;        &#10;        # assure the columns names with leading &#38; trailing '_' &#10;        # are reserved for internal purpose only&#10;        column = column.strip('_')&#10;        &#10;        # get new node id&#10;        self.__node_counter = self.__node_counter + 1&#10;        node_id = NodeID(self.__node_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = node_id,&#10;            data=dict(&#10;                title=&#34;&#34;,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_NODE,&#10;                column = column.strip('_'),&#10;                style = style.strip('_'),&#10;                stack = stack,&#10;                chapter_id = ChapterID(self.__chapter_counter),&#10;                ),&#10;            )&#10;        &#10;        # add edge&#10;        if isinstance(relates_to_node_id, NodeID):&#10;            self._graph.add_edge(&#10;                u_of_edge=node_id,&#10;                v_of_edge=relates_to_node_id,&#10;                data=dict(&#10;                    title=&#34;&#34;,&#10;                    content=relation_content,&#10;                    ),&#10;                metadata=dict(&#10;                    time=str(self._get_timestamp()),&#10;                    type=_EDGE,&#10;                    style=relation_style.strip('_'),&#10;                    ),&#10;                )&#10;        &#10;        return node_id&#10;    &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                               new_chapter                              ##&#10;    ##------------------------------------------------------------------------##&#10;    def new_chapter(self, &#10;                    title:str,&#10;                    style:str=&#34;default&#34;, &#10;                    content:Any=None) -> None:&#10;        &#34;&#34;&#34; Create new chapter, thus partitioning the log-graph in &#10;            vertical manner.&#10;&#10;        :param title: Title of the chapter displayed in ll_logger_app.&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        &#34;&#34;&#34;&#10;        # get new node id&#10;        self.__chapter_counter = self.__chapter_counter + 1&#10;        chapter_id = ChapterID(self.__chapter_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = chapter_id,&#10;            data=dict(&#10;                title=title,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_CHAPTER,&#10;                style = style.strip('_'),&#10;                ),&#10;            )&#10;    &#10;    &#10;    ##------------------------------------------------------------------------##&#10;    ##                                  report                                ##&#10;    ##------------------------------------------------------------------------##&#10;    def report(self):&#10;        chapter_ids_with_node_ids = \&#10;            get_chapter_ids_with_node_ids(graph=self._graph)&#10;        &#10;        for chapter_id, node_ids in chapter_ids_with_node_ids.items():&#10;            print(f&#34;ChapterID = '{chapter_id}'&#34;)&#10;            for node_id in node_ids:&#10;                print(f&#34;   NodeID = '{node_id}'&#34;)&#10;        &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   save                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def save(self, &#10;            path:str=None, &#10;            filename:str=None, &#10;            format=&#34;gml&#34;, &#10;            **kwargs,&#10;        ) -> None:&#10;        &#10;        # parh&#10;        if isinstance(path, type(None)):&#10;            if isinstance(self.path, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'path' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                path = self.path&#10;        else:&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise"
    ]
    metadata [
      time "1717076082.426406"
      type "NODE_"
      column "D"
      style "failure"
      stack 1
      chapter_id "CHAP_000001"
    ]
  ]
  node [
    id 7
    label "CHAP_000002"
    data [
      title "2.S"
      content ""
    ]
    metadata [
      time "1717076082.426482"
      type "CHAP_"
      style "default"
    ]
  ]
  node [
    id 8
    label "NODE_000007"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(projec"
    ]
    metadata [
      time "1717076082.426651"
      type "NODE_"
      column "D"
      style "error"
      stack 0
      chapter_id "CHAP_000002"
    ]
  ]
  node [
    id 9
    label "NODE_000008"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##     "
    ]
    metadata [
      time "1717076082.426793"
      type "NODE_"
      column "D"
      style "decision"
      stack 0
      chapter_id "CHAP_000002"
    ]
  ]
  node [
    id 10
    label "NODE_000009"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   log                                  ##&#10;    ##------------------------------------------------------------------------##&#10;    def log(self, &#10;            column:str=&#34;other&#34;, &#10;            style:str=&#34;default&#34;, &#10;            stack:bool=False,&#10;            content:Any=None, &#10;            relates_to_node_id:NodeID=None, &#10;            relation_content:Any=None,&#10;            relation_style:str=&#34;default&#34;) -> NodeID:&#10;        &#34;&#34;&#34; Create a node in the log-graph, returns the nodes ID. &#10;            The node may be connected to previously logged node using &#10;            'relate_to' given the previ"
    ]
    metadata [
      time "1717076082.426941"
      type "NODE_"
      column "A"
      style "decision"
      stack 0
      chapter_id "CHAP_000002"
    ]
  ]
  node [
    id 11
    label "NODE_000010"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   log                                  ##&#10;    ##------------------------------------------------------------------------##&#10;    def log(self, &#10;            column:str=&#34;other&#34;, &#10;            style:str=&#34;default&#34;, &#10;            stack:bool=False,&#10;            content:Any=None, &#10;            relates_to_node_id:NodeID=None, &#10;            relation_content:Any=None,&#10;            relation_style:str=&#34;default&#34;) -> NodeID:&#10;        &#34;&#34;&#34; Create a node in the log-graph, returns the nodes ID. &#10;            The node may be connected to previously logged node using &#10;            'relate_to' given the previous node ID (self-loops thus do not exists). &#10;&#10;        :param column: Column of the log-graph, defaults to &#34;other&#34;&#10;        :param style: Category relates to the visual style of the node, &#10;            defaults to &#34;default&#34;&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        :param relates_to: Previous node ID to create edge between nodes, &#10;            defaults to None&#10;        :param relation_content: Edge content displayed in llm_logger_app, &#10;            defaults to None&#10;        :param stack: Stack successive nodes with the same column, &#10;            defaults to False&#10;        :return: Unique Node ID.&#10;        &#34;&#34;&#34;&#10;        &#10;        # assure the columns names with leading &#38; trailing '_' &#10;        # are reserved for internal purpose only&#10;        column = column.strip('_')&#10;        &#10;        # get new node id&#10;        self.__node_counter = self.__node_counter + 1&#10;        node_id = NodeID(self.__node_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = node_id,&#10;            data=dict(&#10;                title=&#34;&#34;,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_NODE,&#10;                column = column.strip('_'),&#10;                style = style.strip('_'),&#10;                stack = stack,&#10;                chapter_id = ChapterID(self.__chapter_counter),&#10;                ),&#10;            )&#10;        &#10;        # add edge&#10;        if isinstance(relates_to_node_id, NodeID):&#10;            self._graph.add_edge(&#10;                u_of_edge=node_id,&#10;                v_of_edge=relates_to_node_id,&#10;                data=dict(&#10;                    title=&#34;&#34;,&#10;                    content=relation_content,&#10;                    ),&#10;                metadata=dict(&#10;                    time=str(self._get_timestamp()),&#10;                    type=_EDGE,&#10;                    style=relation_style.strip('_'),&#10;                    ),&#10;                )&#10;        &#10;        return node_id&#10;    &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                               new_chapter                              ##&#10;    ##------------------------------------------------------------------------##&#10;    def new_chapter(self, &#10;                    title:str,&#10;                    style:str=&#34;default&#34;, &#10;                    content:Any=None) -> None:&#10;        &#34;&#34;&#34; Create new chapter, thus partitioning the log-graph in &#10;            vertical manner.&#10;&#10;        :param title: Title of the chapter displayed in ll_logger_app.&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        &#34;&#34;&#34;&#10;        # get new node id&#10;        self.__chapter_counter = self.__chapter_counter + 1&#10;        chapter_id = ChapterID(self.__chapter_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = chapter_id,&#10;            data=dict(&#10;                title=title,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_CHAPTER,&#10;                style = style.strip('_'),&#10;                ),&#10;            )&#10;    &#10;    &#10;    ##------------------------------------------------------------------------##&#10;    ##                                  report                                ##&#10;    ##------------------------------------------------------------------------##&#10;    def report(self):&#10;        chapter_ids_with_node_ids = \&#10;            get_chapter_ids_with_node_ids(graph=self._graph)&#10;        &#10;        for chapter_id, node_ids in chapter_ids_with_node_ids.items():&#10;            print(f&#34;ChapterID = '{chapter_id}'&#34;)&#10;            for node_id in node_ids:&#10;                print(f&#34;   NodeID = '{node_id}'&#34;)&#10;        &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   save                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def save(self, &#10;            path:str=None, &#10;            filename:str=None, &#10;            format=&#34;gml&#34;, &#10;            **kwargs,&#10;        ) -> None:&#10;        &#10;        # parh&#10;        if isinstance(path, type(None)):&#10;            if isinstance(self.path, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'path' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                path = self.path&#10;        else:&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        # filename&#10;        if isinstance(filename, type(None)):&#10;            if isinstance(self.filename, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'filename' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                filename = self.filename&#10;        &#10;        def default_stringizer(value:Any) -> str:&#10;            import re&#10;            if isinstance(value, type(None)):&#10;                return &#34;&#34;&#10;            if isinstance(value, NodeID):&#10;                return str(value)&#10;            if isinstance(value, ChapterID):&#10;                return str(value)&#10;            if isinstance(value, list):&#10;                return str(value)&#10;            if isinstance(value, str):&#10;                return value&#10;            raise ValueError(&#10;                f&#34;default_stringizer undefined conversion for &#34;\&#10;                f&#34;type(value)='{type(value)}'!&#34;)&#10;            &#10;        # save&#10;        if str(format).lower() == &#34;gml&#34;:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;        elif str(format).lower() == &#34;dot&#34;:&#10;            nx.write_dot(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.dot&#34;),&#10;            )&#10;        else:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;            raise TypeError(&#10;                f&#34;Format='{format}', but valid formats=['gml', 'dot']! The graph &#34;\&#10;                f&#34;was saved as {str(pl.Path(path, str(filename)+'.gml'))} &#34;\&#10;                f&#34;to prevent data-loss.&#34;)&#10;&#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   load                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def load(self,&#10;             path_or_buffer:Any,&#10;             filename:str=None,&#10;             **kwargs,&#10;        ) -> nx.Graph: &#10;&#10;        # path or buffer&#10;        suffix = &#34;&#34;&#10;        if isinstance(path_or_buffer, io.BytesIO):&#10;            path = path_or_buffer&#10;            if not isinstance(filename, type(None)):&#10;                suffix = str(pl.Path(filename).suffix).replace(&#34;.&#34;, &#34;&#34;).lower()&#10;        else:&#10;            path = pl.Path(path_or_buffer)&#10;            suffix = str(path.suffix).replace(&#34;.&#34;, &#34;&#34;).lower()&#10;        # default format&#10;        if suffix == &#34;&#34;:&#10;            suffix = &#34;gml&#34;&#10;                &#10;        # read&#10;        if suffix == &#34;gml&#34;:&#10;            graph = nx.read_gml(&#10;                path = path,&#10;                destringizer=kwargs.get(&#34;destringizer&#34;, None),&#10;            )&#10;        elif suffix == &#34;dot&#34;:&#10;            nx.read_dot(&#10;                path = path,&#10;            )&#10;        else:&#10;            graph = nx.read_gml(&#10;                path = path,&#10;                destringizer=kwargs.get(&#34;destringizer&#34;, None),&#10;            )&#10;        &#10;        return graph&#10;    &#10;&#10;    ############################################################################&#10;    ##                                PRIVATE                                 ##&#10;    ############################################################################&#10;    def _test(self, &#10;            num_nodes:int=10, &#10;            num_chapters:int=5, &#10;            num_columns:int=3, &#10;            connectivity:float=0.333) -> nx.Graph:&#10;        &#10;        with open(__file__, &#34;r&#34;) as this_file:&#10;            text = this_file.read()&#10;        len_text = len(text)&#10;        &#10;        rng = np.random.default_rng(num_nodes+num_chapters+num_columns)&#10;        letters = list(map(chr, range(65, 90)))&#10;        styles=[&#34;default&#34;, &#34;decision&#34;, &#34;success&#34;, &#34;failure&#34;, &#34;error&#34;]&#10;        &#10;        def rnd_elem(array, max:int=None) -> int:&#10;            if len(array) == 0:&#10;                return None&#10;            if max is None:&#10;                idx = rng.integers(low=0, high=len(array), size=1)[0]&#10;                return array[idx]&#10;            else:&#10;                if max > len(array):&#10;                    print(array)&#10;                    raise ValueError(f&#34;max={max}, but maximum is {len(array)}!&#34;)&#10;                idx = rng.integers(low=0, high=max, size=1)[0]&#10;                return array[idx]&#10;            &#10;            &#10;        if num_columns > len(letters):&#10;            raise ValueError(&#10;                f&#34;Max. supported num_columns={len(letters)}, &#34;\&#10;                f&#34;but {num_columns} are required!&#34;)&#10;&#10;        count_nodes = 0&#10;        count_chapters = 0&#10;        node_ids = list()&#10;    &#10;        for chapter_idx in range(num_chapters):&#10;            count_chapters = count_chapters + 1&#10;            chapter_title = f&#34;{chapter_idx+1}.&#34; + rnd_elem(letters)&#10;            self.new_chapter(title = chapter_title)&#10;            &#10;            # last chapter&#10;            if chapter_idx == num_chapters-1:&#10;                new_nodes = num_nodes - count_nodes&#10;            else:&#10;                max_new_nodes = int((num_nodes - count_nodes - count_chapters) / 2)&#10;                max"
    ]
    metadata [
      time "1717076082.427154"
      type "NODE_"
      column "A"
      style "decision"
      stack 0
      chapter_id "CHAP_000002"
    ]
  ]
  node [
    id 12
    label "CHAP_000003"
    data [
      title "3.V"
      content ""
    ]
    metadata [
      time "1717076082.427232"
      type "CHAP_"
      style "default"
    ]
  ]
  node [
    id 13
    label "NODE_000011"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;        "
    ]
    metadata [
      time "1717076082.427378"
      type "NODE_"
      column "C"
      style "decision"
      stack 0
      chapter_id "CHAP_000003"
    ]
  ]
  node [
    id 14
    label "NODE_000012"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   log                                  ##&#10;    ##------------------------------------------------------------------------##&#10;    def log(self, &#10;            column:str=&#34;other&#34;, &#10;            style:str=&#34;default&#34;, &#10;            stack:bool=False,&#10;            content:Any=None, &#10;            relates_to_node_id:NodeID=None, &#10;            relation_content:Any=None,&#10;            relation_style:str=&#34;default&#34;) -> NodeID:&#10;        &#34;&#34;&#34; Create a node in the log-graph, returns the nodes ID. &#10;            The node may be connected to previously logged node using &#10;            'relate_to' given the previous node ID (self-loops thus do not exists). &#10;&#10;        :param column: Column of the log-graph, defaults to &#34;other&#34;&#10;        :param style: Category relates to the visual style of the node, &#10;            defaults to &#34;default&#34;&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        :param relates_to: Previous node ID to create edge between nodes, &#10;            defaults to None&#10;        :param relation_content: Edge content displayed in llm_logger_app, &#10;            defaults to None&#10;        :param stack: Stack successive nodes with the same column, &#10;            defaults to False&#10;        :return: Unique Node ID.&#10;        &#34;&#34;&#34;&#10;        &#10;        # assure the columns names with leading &#38; trailing '_' &#10;        # are reserved for internal purpose only&#10;        column = column.strip('_')&#10;        &#10;        # get new node id&#10;        self.__node_counter = self.__node_counter + 1&#10;        node_id = NodeID(self.__node_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = node_id,&#10;            data=dict(&#10;                title=&#34;&#34;,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_NODE,&#10;                column = column.strip('_'),&#10;                style = style.strip('_'),&#10;                stack = stack,&#10;                chapter_id = ChapterID(self.__chapter_counter),&#10;                ),&#10;            )&#10;        &#10;        # add edge&#10;        if isinstance(relates_to_node_id, NodeID):&#10;            self._graph.add_edge(&#10;                u_of_edge=node_id,&#10;                v_of_edge=relates_to_node_id,&#10;                data=dict(&#10;                    title=&#34;&#34;,&#10;                    content=relation_content,&#10;                    ),&#10;                metadata=dict(&#10;                    time=str(self._get_timestamp()),&#10;                    type=_EDGE,&#10;                    style=relation_style.strip('_'),&#10;                    ),&#10;                )&#10;        &#10;        return node_id&#10;    &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                               new_chapter                              ##&#10;    ##------------------------------------------------------------------------##&#10;    def new_chapter(self, &#10;                    title:str,&#10;                    style:str=&#34;default&#34;, &#10;                    content:Any=None) -> None:&#10;        &#34;&#34;&#34; Create new chapter, thus partitioning the log-graph in &#10;            vertical manner.&#10;&#10;        :param title: Title of the chapter displayed in ll_logger_app.&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        &#34;&#34;&#34;&#10;        # get new node id&#10;        self.__chapter_counter = self.__chapter_counter + 1&#10;        chapter_id = ChapterID(self.__chapter_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = chapter_id,&#10;            data=dict(&#10;                title=title,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_CHAPTER,&#10;                style = style.strip('_'),&#10;                ),&#10;            )&#10;    &#10;    &#10;    ##------------------------------------------------------------------------##&#10;    ##                                  report                                ##&#10;    ##------------------------------------------------------------------------##&#10;    def report(self):&#10;        chapter_ids_with_node_ids = \&#10;            get_chapter_ids_with_node_ids(graph=self._graph)&#10;        &#10;        for chapter_id, node_ids in chapter_ids_with_node_ids.items():&#10;            print(f&#34;ChapterID = '{chapter_id}'&#34;)&#10;            for node_id in node_ids:&#10;                print(f&#34;   NodeID = '{node_id}'&#34;)&#10;        &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   save                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def save(self, &#10;            path:str=None, &#10;            filename:str=None, &#10;            format=&#34;gml&#34;, &#10;            **kwargs,&#10;        ) -> None:&#10;        &#10;        # parh&#10;        if isinstance(path, type(None)):&#10;            if isinstance(self.path, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'path' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                path = self.path&#10;        else:&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        # filename&#10;        if isinstance(filename, type(None)):&#10;            if isinstance(self.filename, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'filename' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                filename = self.filename&#10;        &#10;        def default_stringizer(value:Any) -> str:&#10;            import re&#10;            if isinstance(value, type(None)):&#10;                return &#34;&#34;&#10;            if isinstance(value, NodeID):&#10;                return str(value)&#10;            if isinstance(value, ChapterID):&#10;                return str(value)&#10;            if isinstance(value, list):&#10;                return str(value)&#10;            if isinstance(value, str):&#10;                return value&#10;            raise ValueError(&#10;                f&#34;default_stringizer undefined conversion for &#34;\&#10;                f&#34;type(value)='{type(value)}'!&#34;)&#10;            &#10;        # save&#10;        if str(format).lower() == &#34;gml&#34;:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;        elif str(format).lower() == &#34;dot&#34;:&#10;            nx.write_dot(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.dot&#34;),&#10;            )&#10;        else:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;            raise TypeError(&#10;                f&#34;Format='{format}', but valid formats=['gml', 'dot']! The graph &#34;\&#10;                f&#34;was saved as {str(pl.Path(path, str(filename)+'.gml'))} &#34;\&#10;                f&#34;to prevent data-loss.&#34;)&#10;&#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   load                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def load(self,&#10;             path_or_buffer:Any,&#10;             filename:str=None,&#10;             **kwargs,&#10;        ) -> nx.Graph: &#10;&#10;        # path or buffer&#10;        suffix = &#34;&#34;&#10;        if isinstance(path_or_buffer, io.BytesIO):&#10;            path = path_or_buffer&#10;            if not isinstance(filename, type(None)):&#10;                suffix = str(pl.Path(filename).suffix).replace(&#34;.&#34;, &#34;&#34;).lower()&#10;        else:&#10;            path = pl.Path(path"
    ]
    metadata [
      time "1717076082.427527"
      type "NODE_"
      column "B"
      style "default"
      stack 0
      chapter_id "CHAP_000003"
    ]
  ]
  node [
    id 15
    label "NODE_000013"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   log                                  ##&#10;    ##------------------------------------------------------------------------##&#10;    def log(self, &#10;            column:str=&#34;other&#34;, &#10;            style:str=&#34;default&#34;, &#10;            stack:bool=False,&#10;            content:Any=None, &#10;            relates_to_node_id:NodeID=None, &#10;            relation_content:Any=None,&#10;            relation_style:str=&#34;default&#34;) -> NodeID:&#10;        &#34;&#34;&#34; Create a node in the log-graph, returns the nodes ID. &#10;            The node may be connected to previously logged node using &#10;            'relate_to' given the previous node ID (self-loops thus do not exists). &#10;&#10;        :param column: Column of the log-graph, defaults to &#34;other&#34;&#10;        :param style: Category relates to the visual style of the node, &#10;            defaults to &#34;default&#34;&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        :param relates_to: Previous node ID to create edge between nodes, &#10;            defaults to None&#10;        :param relation_content: Edge content displayed in llm_logger_app, &#10;            defaults to None&#10;        :param stack: Stack successive nodes with the same column, &#10;            defaults to False&#10;        :return: Unique Node ID.&#10;        &#34;&#34;&#34;&#10;        &#10;        # assure the columns names with leading &#38; trailing '_' &#10;        # are reserved for internal purpose only&#10;        column = column.strip('_')&#10;        &#10;        # get new node id&#10;        self.__node_counter = self.__node_counter + 1&#10;        node_id = NodeID(self.__node_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = node_id,&#10;            data=dict(&#10;                title=&#34;&#34;,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_NODE,&#10;                column = column.strip('_'),&#10;                style = style.strip('_'),&#10;                stack = stack,&#10;                chapter_id = ChapterID(self.__chapter_counter),&#10;                ),&#10;            )&#10;        &#10;        # add edge&#10;        if isinstance(relates_to_node_id, NodeID):&#10;            self._graph.add_edge(&#10;                u_of_edge=node_id,&#10;                v_of_edge=relates_to_node_id,&#10;                data=dict(&#10;                    title=&#34;&#34;,&#10;                    content=relation_content,&#10;                    ),&#10;                metadata=dict(&#10;                    time=str(self._get_timestamp()),&#10;                    type=_EDGE,&#10;                    style=relation_style.strip('_'),&#10;                    ),&#10;                )&#10;        &#10;        return node_id&#10;    &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                               new_chapter                              ##&#10;    ##------------------------------------------------------------------------##&#10;    def new_chapter(self, &#10;                    title:str,&#10;                    style:str=&#34;default&#34;, &#10;                    content:Any=None) -> None:&#10;        &#34;&#34;&#34; Create new chapter, thus partitioning the log-graph in &#10;            vertical manner.&#10;&#10;        :param title: Title of the chapter displayed in ll_logger_app.&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        &#34;&#34;&#34;&#10;        # get new node id&#10;        self.__chapter_counter = self.__chapter_counter + 1&#10;        chapter_id = ChapterID(self.__chapter_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = chapter_id,&#10;            data=dict(&#10;                title=title,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_CHAPTER,&#10;                style = style.strip('_'),&#10;                ),&#10;            )&#10;    &#10;    &#10;    ##------------------------------------------------------------------------##&#10;    ##                                  report                                ##&#10;    ##------------------------------------------------------------------------##&#10;    def report(self):&#10;        chapter_ids_with_node_ids = \&#10;            get_chapter_ids_with_node_ids(graph=self._graph)&#10;        &#10;        for chapter_id, node_ids in chapter_ids_with_node_ids.items():&#10;            print(f&#34;ChapterID = '{chapter_id}'&#34;)&#10;            for node_id in node_ids:&#10;                print(f&#34;   NodeID = '{node_id}'&#34;)&#10;        &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   save                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def save(self, &#10;            path:str=None, &#10;            filename:str=None, &#10;            format=&#34;gml&#34;, &#10;            **kwargs,&#10;        ) -> None:&#10;        &#10;        # parh&#10;        if isinstance(path, type(None)):&#10;            if isinstance(self.path, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'path' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                path = self.path&#10;        else:&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        # filename&#10;        if isinstance(filename, type(None)):&#10;            if isinstance(self.filename, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'filename' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                filename = self.filename&#10;        &#10;        def default_stringizer(value:Any) -> str:&#10;            import re&#10;            if isinstance(value, type(None)):&#10;                return &#34;&#34;&#10;            if isinstance(value, NodeID):&#10;                return str(value)&#10;            if isinstance(value, ChapterID):&#10;                return str(value)&#10;            if isinstance(value, list):&#10;                return str(value)&#10;            if isinstance(value, str):&#10;                return value&#10;            raise ValueError(&#10;                f&#34;default_stringizer undefined conversion for &#34;\&#10;                f&#34;type(value)='{type(value)}'!&#34;)&#10;            &#10;        # save&#10;        if str(format).lower() == &#34;gml&#34;:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;        elif str(format).lower() == &#34;dot&#34;:&#10;            nx.write_dot(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.dot&#34;),&#10;            )&#10;        else:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;            raise TypeError(&#10;                f&#34;Format='{format}', but valid formats=['gml', 'dot']! The graph &#34;\&#10;                f&#34;was saved as {str(pl.Path(path, str(filename)+'.gml'))} &#34;\&#10;                f&#34;to prevent data-loss.&#34;)&#10;&#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   load                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def load(self,&#10;             path_or_buffer:Any,&#10;             filename:str=None,&#10;             **kwargs,&#10;        ) -> nx.Graph: &#10;&#10;        # path or buffer&#10;        suffix = &#34;&#34;&#10;        if isinstance(path_or_buffer, io.BytesIO):&#10;            path = path_or_buffer&#10;            if not isinstance(filename, type(None)):&#10;                suffix = str(pl.Path(filename).suffix).replace(&#34;.&#34;, &#34;&#34;).lower()&#10;        else:&#10;            path = pl.Path(path_or_buffer)&#10;            suffix = str(path.suffix).replace(&#34;.&#34;, &#34;&#34;).lower()&#10;        # default format&#10;        if suffix == &#34;&#34;:&#10;            suffix = &#34;gml&#34;&#10;                &#10;        # read&#10;        if suffix == &#34;gml&#34;:&#10;            graph = nx.read_gml(&#10;                path = path,&#10;                destringizer=kwargs.get(&#34;destringizer&#34;, None),&#10;            )&#10;        elif suffix == &#34;dot&#34;:&#10;            nx.read_dot(&#10;                path = path,&#10;            )&#10;        else:&#10;            graph = nx.read_gml(&#10;                path = path,&#10;                destringizer=kwargs.get(&#34;destringizer&#34;, None),&#10;            )&#10;        &#10;        return graph&#10;    &#10;&#10;    ############################################################################&#10;    ##                                PRIVATE                                 ##&#10;    ############################################################################&#10;    def _test(self, &#10;            num_nodes:int=10, &#10;            num_chapters:int=5, &#10;            num_columns:int=3, &#10;            connectivity:float=0.333) -> nx.Graph:&#10;        &#10;        with open(__file__, &#34;r&#34;) as this_file:&#10;            text = this_file.read()&#10;        len_text = len(text)&#10;        &#10;        rng = np.random.default_rng(num_nodes+num_chapters+num_columns)&#10;        letters = list(map(chr, range(65, 90)))&#10;        styles=[&#34;default&#34;, &#34;decision&#34;, &#34;success&#34;, &#34;failure&#34;, &#34;error&#34;]&#10;        &#10;        def rnd_elem(array, max:int=None) -> int:&#10;            if len(array) == 0:&#10;                return None&#10;            if max is None:&#10;                idx = rng.integers(low=0, high=len(array), size=1)[0]&#10;                return array[idx]&#10;            else:&#10;                if max > len(array):&#10;                    print(array)&#10;                    raise ValueError(f&#34;max={max}, but maximum is {len(array)}!&#34;)&#10;                idx = rng.integers(low=0, high=max, size=1)[0]&#10;                return array[idx]&#10;            &#10;            &#10;        if num_columns > len(letters):&#10;            raise ValueError(&#10;                f&#34;Max. supported num_columns={len(letters)}, &#34;\&#10;                f&#34;but {num_columns} are required!&#34;)&#10;&#10;        count_nodes = 0&#10;        count_chapters = 0&#10;        node_ids = list()&#10;    &#10;        for chapter_idx in range(num_chapters):&#10;            count_chapters = count_chapters + 1&#10;            chapter_title = f&#34;{chapter_idx+1}.&#34; + rnd_elem(letters)&#10;            self.new_chapter(title = chapter_title)&#10;            &#10;            # last chapter&#10;            if chapter_idx == num_chapters-1:&#10;                new_nodes = num_nodes - count_nodes&#10;            else:&#10;                max_new_nodes = int((num_nodes - count_nodes - count_chapters) / 2)&#10;                max_new_nodes = max_new_nodes if max_new_nodes > 0 else 0&#10;                new_nodes = rng.integers(low=0, high=max_new_nodes+1, size=1)[0]&#10;                &#10;            for node_idx in range(new_nodes):&#10;                node_id = self.log(&#10;                    column=rnd_elem(letters, max=num_columns), &#10;                    style=rnd_elem(styles), &#10;                    stack=rnd_elem([True, False]),&#10;        "
    ]
    metadata [
      time "1717076082.427693"
      type "NODE_"
      column "A"
      style "failure"
      stack 1
      chapter_id "CHAP_000003"
    ]
  ]
  node [
    id 16
    label "NODE_000014"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   log                                  ##&#10;    ##------------------------------------------------------------------------##&#10;    def log(self, &#10;            column:str=&#34;other&#34;, &#10;            style:str=&#34;default&#34;, &#10;            stack:bool=False,&#10;            content:Any=None, &#10;            relates_to_node_id:NodeID=None, &#10;            relation_content:Any=None,&#10;            relation_style:str=&#34;default&#34;) -> NodeID:&#10;        &#34;&#34;&#34; Create a node in the log-graph, returns the nodes ID. &#10;            The node may be connected to previously logged node using &#10;            'relate_to' given the previous node ID (self-loops thus do not exists). &#10;&#10;        :param column: Column of the log-graph, defaults to &#34;other&#34;&#10;        :param style: Category relates to the visual style of the node, &#10;            defaults to &#34;default&#34;&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        :param relates_to: Previous node ID to create edge between nodes, &#10;            defaults to None&#10;        :param relation_content: Edge content displayed in llm_logger_app, &#10;            defaults to None&#10;        :param stack: Stack successive nodes with the same column, &#10;            defaults to False&#10;        :return: Unique Node ID.&#10;        &#34;&#34;&#34;&#10;        &#10;        # assure the columns names with leading &#38; trailing '_' &#10;        # are reserved for internal purpose only&#10;        column = column.strip('_')&#10;        &#10;        # get new node id&#10;        self.__node_counter = self.__node_counter + 1&#10;        node_id = NodeID(self.__node_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = node_id,&#10;            data=dict(&#10;                title=&#34;&#34;,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_NODE,&#10;                column = column.strip('_'),&#10;                style = style.strip('_'),&#10;                stack = stack,&#10;                chapter_id = ChapterID(self.__chapter_counter),&#10;                ),&#10;            )&#10;        &#10;        # add edge&#10;        if isinstance(relates_to_node_id, NodeID):&#10;            self._graph.add_edge(&#10;                u_of_edge=node_id,&#10;                v_of_edge=relates_to_node_id,&#10;                data=dict(&#10;                    title=&#34;&#34;,&#10;                    content=relation_content,&#10;                    ),&#10;                metadata=dict(&#10;                    time=str(self._get_timestamp()),&#10;                    type=_EDGE,&#10;                    style=relation_style.strip('_'),&#10;                    ),&#10;                )&#10;        &#10;        return node_id&#10;    &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                               new_chapter                              ##&#10;    ##------------------------------------------------------------------------##&#10;    def new_chapter(self, &#10;                    title:str,&#10;                    style:str=&#34;default&#34;, &#10;                    content:Any=None) -> None:&#10;        &#34;&#34;&#34; Create new chapter, thus partitioning the log-graph in &#10;            vertical manner.&#10;&#10;        :param title: Title of the chapter displayed in ll_logger_app.&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        &#34;&#34;&#34;&#10;        # get new node id&#10;        self.__chapter_counter = self.__chapter_counter + 1&#10;        chapter_id = ChapterID(self.__chapter_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = chapter_id,&#10;            data=dict(&#10;                title=title,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_CHAPTER,&#10;                style = style.strip('_'),&#10;                ),&#10;            )&#10;    &#10;    &#10;    ##------------------------------------------------------------------------##&#10;    ##                                  report                                ##&#10;    ##------------------------------------------------------------------------##&#10;    def report(self):&#10;        chapter_ids_with_node_ids = \&#10;            get_chapter_ids_with_node_ids(graph=self._graph)&#10;        &#10;        for chapter_id, node_ids in chapter_ids_with_node_ids.items():&#10;            print(f&#34;ChapterID = '{chapter_id}'&#34;)&#10;            for node_id in node_ids:&#10;                print(f&#34;   NodeID = '{node_id}'&#34;)&#10;        &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   save                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def save(self, &#10;            path:str=None, &#10;            filename:str=None, &#10;            format=&#34;gml&#34;, &#10;            **kwargs,&#10;        ) -> None:&#10;        &#10;        # parh&#10;        if isinstance(path, type(None)):&#10;            if isinstance(self.path, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'path' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                path = self.path&#10;        else:&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        # filename&#10;        if isinstance(filename, type(None)):&#10;            if isinstance(self.filename, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'filename' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                filename = self.filename&#10;        &#10;        def default_stringizer(value:Any) -> str:&#10;            import re&#10;            if isinstance(value, type(None)):&#10;                return &#34;&#34;&#10;            if isinstance(value, NodeID):&#10;                return str(value)&#10;            if isinstance(value, ChapterID):&#10;                return str(value)&#10;            if isinstance(value, list):&#10;                return str(value)&#10;            if isinstance(value, str):&#10;                return value&#10;            raise ValueError(&#10;                f&#34;default_stringizer undefined conversion for &#34;\&#10;                f&#34;type(value)='{type(value)}'!&#34;)&#10;            &#10;        # save&#10;        if str(format).lower() == &#34;gml&#34;:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;        elif str(format).lower() == &#34;dot&#34;:&#10;            nx.write_dot(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.dot&#34;),&#10;            )&#10;        else:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;            raise TypeError(&#10;                f&#34;Format='{format}', but valid formats=['gml', 'dot']! The graph &#34;\&#10;                f&#34;was saved as {str(pl.Path(path, str(filename)+'.gml'))} &#34;\&#10;                f&#34;to prevent data-loss.&#34;)&#10;&#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   load                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def load(self,&#10;             path_or_buffer:Any,&#10;             filename:str=None,&#10;             **kwargs,&#10;        ) -> nx.Graph: &#10;&#10;        # path or buffer&#10;        suffix = &#34;&#34;&#10;        if isinstance(path_or_buffer, io.BytesIO):&#10;            path = path_or_buffer&#10;            if not isinstance(filename, type(None)):&#10;                suffix = str(pl.Path(filename).suffix).replace(&#34;.&#34;, &#34;&#34;).lower()&#10;        else:&#10;            path = pl.Path(path_or_buffer)&#10;            suffix = str(path.suffix).replace(&#34;.&#34;, &#34;&#34;).lower()&#10;        # default format&#10;        if suffix == &#34;&#34;:&#10;            suffix = &#34;gml&#34;&#10;                &#10;        # read&#10;        if suffix == &#34;gml&#34;:&#10;            graph = nx.read_gml(&#10;                path = path,&#10;                destringizer=kwargs.get(&#34;destringizer&#34;, None),&#10;            )&#10;        elif suffix == &#34;dot&#34;:&#10;            nx.read_dot(&#10;                path = path,&#10;            )&#10;        else:&#10;            graph = nx.read_gml(&#10;                path = path,&#10;                destringizer=kwargs.get(&#34;destringizer&#34;, None),&#10;            )&#10;        &#10;        return graph&#10;    &#10;&#10;    ############################################################################&#10;    ##                                PRIVATE                                 ##&#10;    ############################################################################&#10;    def _test(self, &#10;            num_nodes:int=10, &#10;            num_chapters:int=5, &#10;            num_columns:int=3, &#10;            connectivity:float=0.333) -> nx.Graph:&#10;        &#10;        with open(__file__, &#34;r&#34;) as this_file:&#10;            text = this_file.read()&#10;        len_text = len(text)&#10;        &#10;        rng = np.random.default_rng(num_nodes+num_chapters+num_columns)&#10;        letters = list(map(chr, range(65, 90)))&#10;        styles=[&#34;default&#34;, &#34;decision&#34;, &#34;success&#34;, &#34;failure&#34;, &#34;error&#34;]&#10;        &#10;        def rnd_elem(array, max:int=None) -> int:&#10;            if len(array) == 0:&#10;                return None&#10;            if max is None:&#10;                idx = rng.integers(low=0, high=len(array), size=1)[0]&#10;                return array[idx]&#10;            else:&#10;                if max > len(array):&#10;                    print(array)&#10;                    raise ValueError(f&#34;max={max}, "
    ]
    metadata [
      time "1717076082.427872"
      type "NODE_"
      column "D"
      style "failure"
      stack 1
      chapter_id "CHAP_000003"
    ]
  ]
  node [
    id 17
    label "NODE_000015"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##--------------------------------------------------------------"
    ]
    metadata [
      time "1717076082.428051"
      type "NODE_"
      column "B"
      style "failure"
      stack 1
      chapter_id "CHAP_000003"
    ]
  ]
  node [
    id 18
    label "NODE_000016"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if no"
    ]
    metadata [
      time "1717076082.428215"
      type "NODE_"
      column "A"
      style "default"
      stack 0
      chapter_id "CHAP_000003"
    ]
  ]
  node [
    id 19
    label "NODE_000017"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   log                                  ##&#10;    ##------------------------------------------------------------------------##&#10;    def log(self, &#10;            column:str=&#34;other&#34;, &#10;            style:str=&#34;default&#34;, &#10;            stack:bool=False,&#10;            content:Any=None, &#10;            relates_to_node_id:NodeID=None, &#10;            relation_content:Any=None,&#10;            relation_style:str=&#34;default&#34;) -> NodeID:&#10;        &#34;&#34;&#34; Create a node in the log-graph, returns the nodes ID. &#10;            The node may be connected to previously logged node using &#10;            'relate_to' given the previous node ID (self-loops thus do not exists). &#10;&#10;        :param column: Column of the log-graph, defaults to &#34;other&#34;&#10;        :param style: Category relates to the visual style of the node, &#10;            defaults to &#34;default&#34;&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        :param relates_to: Previous node ID to create edge between nodes, &#10;            defaults to None&#10;        :param relation_content: Edge content displayed in llm_logger_app, &#10;            defaults to None&#10;        :param stack: Stack successive nodes with the same column, &#10;            defaults to False&#10;        :return: Unique Node ID.&#10;        &#34;&#34;&#34;&#10;        &#10;        # assure the columns names with leading &#38; trailing '_' &#10;        # are reserved for internal purpose only&#10;        column = column.strip('_')&#10;        &#10;        # get new node id&#10;        self.__node_counter = self.__node_counter + 1&#10;        node_id = NodeID(self.__node_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = node_id,&#10;            data=dict(&#10;                title=&#34;&#34;,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_NODE,&#10;                column = column.strip('_'),&#10;                style = style.strip('_'),&#10;                stack = stack,&#10;                chapter_id = ChapterID(self.__chapter_counter),&#10;                ),&#10;            )&#10;        &#10;        # add edge&#10;        if isinstance(relates_to_node_id, NodeID):&#10;            self._graph.add_edge(&#10;                u_of_edge=node_id,&#10;                v_of_edge=relates_to_node_id,&#10;                data=dict(&#10;                    title=&#34;&#34;,&#10;                    content=relation_content,&#10;                    ),&#10;                metadata=dict(&#10;                    time=str(self._get_timestamp()),&#10;                    type=_EDGE,&#10;                    style=relation_style.strip('_'),&#10;                    ),&#10;                )&#10;        &#10;        return node_id&#10;    &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                               new_chapter                              ##&#10;    ##------------------------------------------------------------------------##&#10;    def new_chapter(self, &#10;                    title:str,&#10;                    style:str=&#34;default&#34;, &#10;                    content:Any=None) -> None:&#10;        &#34;&#34;&#34; Create new chapter, thus partitioning the log-graph in &#10;            vertical manner.&#10;&#10;        :param title: Title of the chapter displayed in ll_logger_app.&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        &#34;&#34;&#34;&#10;        # get new node id&#10;        self.__chapter_counter = self.__chapter_counter + 1&#10;        chapter_id = ChapterID(self.__chapter_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = chapter_id,&#10;            data=dict(&#10;                title=title,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_CHAPTER,&#10;                style = style.strip('_'),&#10;                ),&#10;            )&#10;    &#10;    &#10;    ##------------------------------------------------------------------------##&#10;    ##                                  report                                ##&#10;    ##------------------------------------------------------------------------##&#10;    def report(self):&#10;        chapter_ids_with_node_ids = \&#10;            get_chapter_ids_with_node_ids(graph=self._graph)&#10;        &#10;        for chapter_id, node_ids in chapter_ids_with_node_ids.items():&#10;            print(f&#34;ChapterID = '{chapter_id}'&#34;)&#10;            for node_id in node_ids:&#10;                print(f&#34;   NodeID = '{node_id}'&#34;)&#10;        &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   save                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def save(self, &#10;            path:str=None, &#10;            filename:str=None, &#10;            format=&#34;gml&#34;, &#10;            **kwargs,&#10;        ) -> None:&#10;        &#10;        # parh&#10;        if isinstance(path, type(None)):&#10;            if isinstance(self.path, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'path' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                path = self.path&#10;        else:&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        # filename&#10;        if isinstance(filename, type(None)):&#10;            if isinstance(self.filename, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'filename' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                filename = self.filename&#10;        &#10;        def default_stringizer(value:Any) -> str:&#10;            import re&#10;            if isinstance(value, type(None)):&#10;                return &#34;&#34;&#10;            if isinstance(value, NodeID):&#10;                return str(value)&#10;            if isinstance(value, ChapterID):&#10;                return str(value)&#10;            if isinstance(value, list):&#10;                return str(value)&#10;            if isinstance(value, str):&#10;                return value&#10;            raise ValueError(&#10;                f&#34;default_stringizer undefined conversion for &#34;\&#10;                f&#34;type(value)='{type(value)}'!&#34;)&#10;            &#10;        # save&#10;        if str(format).lower() == &#34;gml&#34;:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;        elif str(format).lower() == &#34;dot&#34;:&#10;            nx.write_dot(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.dot&#34;),&#10;            )&#10;        else:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;            raise TypeError(&#10;                f&#34;Format='{format}', but valid formats=['gml', 'dot']! The graph &#34;\&#10;                f&#34;was saved as {str(pl.Path(path, str(filename)+'.gml'))} &#34;\&#10;                f&#34;to prevent data-loss.&#34;)&#10;&#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   load                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def load(self,&#10;             path_or_buffer:Any,&#10;             filename:str=None,&#10;             **kwargs,&#10;        ) -> nx.Graph: &#10;&#10;        # path or buffer&#10;        suffix = &#34;&#34;&#10;        if isinstance(path_or_buffer, io.BytesIO):&#10;            path = path_or_buffer&#10;            if not isinstance(filename, type(None)):&#10;                suffix = str(pl.Path(filename).suffix).replace(&#34;.&#34;, &#34;&#34;).lower()&#10;        else:&#10;            path = pl.Path(path_or_buffer)&#10;            suffix = str(path.suffix).replace(&#34;.&#34;, &#34;&#34;).lower()&#10;        # default format&#10;        if suffix == &#34;&#34;:&#10;            suffix = &#34;gml&#34;&#10;                &#10;        # read&#10;        if suffix == &#34;gml&#34;:&#10;            graph = nx.read_gml(&#10;                path = path,&#10;                destringizer=kwargs.get(&#34;destringizer&#34;, None),&#10;            )&#10;        elif suffix == &#34;dot&#34;:&#10;            nx.read_dot(&#10;                path = path,&#10;            )&#10;        else:&#10;            graph = nx.read_gml(&#10;                path = path,&#10;                destringizer=kwargs.get(&#34;destringizer&#34;, None),&#10;            )&#10;        &#10;        return graph&#10;    &#10;&#10;    ############################################################################&#10;    ##                                PRIVATE                                 ##&#10;    ############################################################################&#10;    def _test(self, &#10;            num_nodes:int=10, &#10;            num_chapters:int=5, &#10;            num_columns:int=3, &#10;            connectivity:float=0.333) -> nx.Graph:&#10;        &#10;        with open(__file__, &#34;r&#34;) as this_file:&#10;            text = this_file.read()&#10;        len_text = len(text)&#10;        &#10;        rng = np.random.default_rng(num_nodes+num_chapters+num_columns)&#10;        letters = list(map(chr, range(65, 90)))&#10;        styles=[&#34;default&#34;, &#34;decision&#34;, &#34;success&#34;, &#34;failure&#34;, &#34;error&#34;]&#10;        &#10;        def rnd_elem(array, max:int=None) -> int:&#10;            if len(array) == 0:&#10;                return None&#10;            if max is None:&#10;                idx = rng.integers(low=0, high=len(array), size=1)[0]&#10;                return array[idx]&#10;            else:&#10;                if max > len(array):&#10;                    print(array)&#10;                    raise ValueError(f&#34;max={max}, but maximum is {len(array)}!&#34;)&#10;                idx = rng.integers(low=0, high=max, size=1)[0]&#10;                return array[idx]&#10;            &#10;            &#10;        if num_columns > len(letters):&#10;            raise ValueError(&#10;                f&#34;Max. supported num_columns={len(letters)}, &#34;\&#10;                f&#34;but {num_columns} are required!&#34;)&#10;&#10;        count_nodes = 0&#10;        count_chapters = 0&#10;        node_ids = list()&#10;    &#10;        for chapter_idx in range(num_chapters):&#10;            count_chapters = count_chapters + 1&#10;            chapter_title = f&#34;{chapter_idx+1}.&#34; + rnd_elem(letters)&#10;            self.new_chapter(title = chapter_title)&#10;            &#10;            # last chapter&#10;            if chapter_idx == num_chapters-1:&#10;                new_nodes = num_nodes - count_nodes&#10;            else:&#10;                max_new_nodes = int((num_nodes - count_nodes - count_chapters) / 2)&#10;                max_new_nodes = max_new_nodes if max_new_nodes > 0 else 0&#10;                new_nodes ="
    ]
    metadata [
      time "1717076082.428364"
      type "NODE_"
      column "C"
      style "success"
      stack 1
      chapter_id "CHAP_000003"
    ]
  ]
  node [
    id 20
    label "NODE_000018"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   log                                  ##&#10;    ##------------------------------------------------------------------------##&#10;    def log(self, &#10;            column:str=&#34;other&#34;, &#10;            style:str=&#34;default&#34;, &#10;            stack:bool=False,&#10;            content:Any=None, &#10;            relates_to_node_id:NodeID=None, &#10;            relation_content:Any=None,&#10;            relation_style:str=&#34;default&#34;) -> NodeID:&#10;        &#34;&#34;&#34; Create a node in the log-graph, returns the nodes ID. &#10;            The node may be connected to previously logged node using &#10;            'relate_to' given the previous node ID (self-loops thus do not exists). &#10;&#10;        :param column: Column of the log-graph, defaults to &#34;other&#34;&#10;        :param style: Category relates to the visual style of the node, &#10;            defaults to &#34;default&#34;&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        :param relates_to: Previous node ID to create edge between nodes, &#10;            defaults to None&#10;        :param relation_content: Edge content displayed in llm_logger_app, &#10;            defaults to None&#10;        :param stack: Stack successive nodes with the same column, &#10;            defaults to False&#10;        :return: Unique Node ID.&#10;        &#34;&#34;&#34;&#10;        &#10;        # assure the columns names with leading &#38; trailing '_' &#10;        # are reserved for internal purpose only&#10;        column = column.strip('_')&#10;        &#10;        # get new node id&#10;        self.__node_counter = self.__node_counter + 1&#10;        node_id = NodeID(self.__node_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = node_id,&#10;            data=dict(&#10;                title=&#34;&#34;,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_NODE,&#10;                column = column.strip('_'),&#10;                style = style.strip('_'),&#10;                stack = stack,&#10;                chapter_id = ChapterID(self.__chapter_counter),&#10;                ),&#10;            )&#10;        &#10;        # add edge&#10;        if isinstance(relates_to_node_id, NodeID):&#10;            self._graph.add_edge(&#10;                u_of_edge=node_id,&#10;                v_of_edge=relates_to_node_id,&#10;                data=dict(&#10;                    title=&#34;&#34;,&#10;                    content=relation_content,&#10;                    ),&#10;                metadata=dict(&#10;                    time=str(self._get_timestamp()),&#10;                    type=_EDGE,&#10;                    style=relation_style.strip('_'),&#10;                    ),&#10;                )&#10;        &#10;        return node_id&#10;    &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                               new_chapter                              ##&#10;    ##------------------------------------------------------------------------##&#10;    def new_chapter(self, &#10;                    title:str,&#10;                    style:str=&#34;default&#34;, &#10;                    content:Any=None) -> None:&#10;        &#34;&#34;&#34; Create new chapter, thus partitioning the log-graph in &#10;            vertical manner.&#10;&#10;        :param title: Title of the chapter displayed in ll_logger_app.&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        &#34;&#34;&#34;&#10;        # get new node id&#10;        self.__chapter_counter = self.__chapter_counter + 1&#10;        chapter_id = ChapterID(self.__chapter_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = chapter_id,&#10;            data=dict(&#10;                title=title,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_CHAPTER,&#10;                style = style.strip('_'),&#10;                ),&#10;            )&#10;    &#10;    &#10;    ##------------------------------------------------------------------------##&#10;    ##                                  report                                ##&#10;    ##------------------------------------------------------------------------##&#10;    def report(self):&#10;        chapter_ids_with_node_ids = \&#10;            get_chapter_ids_with_node_ids(graph=self._graph)&#10;        &#10;        for chapter_id, node_ids in chapter_ids_with_node_ids.items():&#10;            print(f&#34;ChapterID = '{chapter_id}'&#34;)&#10;            for node_id in node_ids:&#10;                print(f&#34;   NodeID = '{node_id}'&#34;)&#10;        &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   save                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def save(self, &#10;            path:str=None, &#10;            filename:str=None, &#10;            format=&#34;gml&#34;, &#10;            **kwargs,&#10;        ) -> None:&#10;        &#10;        # parh&#10;        if isinstance(path, type(None)):&#10;            if isinstance(self.path, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'path' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                path = self.path&#10;        else:&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f"
    ]
    metadata [
      time "1717076082.428502"
      type "NODE_"
      column "B"
      style "default"
      stack 0
      chapter_id "CHAP_000003"
    ]
  ]
  node [
    id 21
    label "NODE_000019"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        else:&#10;            path = None&#10;&#10;        self.path = path&#10;        self.file = filename&#10;        &#10;        # state variables&#10;        self._graph = nx.Graph(&#10;            metadata=dict(time=str(self._get_timestamp())),&#10;            )&#10;        self.__chapter_counter = 0&#10;        self.__node_counter = 0&#10;        &#10;    ############################################################################&#10;    ##                               ATTRIBUTES                               ##&#10;    ############################################################################        &#10;    &#10;    @property&#10;    def graph(self):&#10;        return copy.deepcopy(self._graph)&#10;    &#10;    ############################################################################&#10;    ##                                 PUBLIC                                 ##&#10;    ############################################################################&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   log                                  ##&#10;    ##------------------------------------------------------------------------##&#10;    def log(self, &#10;            column:str=&#34;other&#34;, &#10;            style:str=&#34;default&#34;, &#10;            stack:bool=False,&#10;            content:Any=None, &#10;            relates_to_node_id:NodeID=None, &#10;            relation_content:Any=None,&#10;            relation_style:str=&#34;default&#34;) -> NodeID:&#10;        &#34;&#34;&#34; Create a node in the log-graph, returns the nodes ID. &#10;            The node may be connected to previously logged node using &#10;            'relate_to' given the previous node ID (self-loops thus do not exists). &#10;&#10;        :param column: Column of the log-graph, defaults to &#34;other&#34;&#10;        :param style: Category relates to the visual style of the node, &#10;            defaults to &#34;default&#34;&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        :param relates_to: Previous node ID to create edge between nodes, &#10;            defaults to None&#10;        :param relation_content: Edge content displayed in llm_logger_app, &#10;            defaults to None&#10;        :param stack: Stack successive nodes with the same column, &#10;            defaults to False&#10;        :return: Unique Node ID.&#10;        &#34;&#34;&#34;&#10;        &#10;        # assure the columns names with leading &#38; trailing '_' &#10;        # are reserved for internal purpose only&#10;        column = column.strip('_')&#10;        &#10;        # get new node id&#10;        self.__node_counter = self.__node_counter + 1&#10;        node_id = NodeID(self.__node_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = node_id,&#10;            data=dict(&#10;                title=&#34;&#34;,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_NODE,&#10;                column = column.strip('_'),&#10;                style = style.strip('_'),&#10;                stack = stack,&#10;                chapter_id = ChapterID(self.__chapter_counter),&#10;                ),&#10;            )&#10;        &#10;        # add edge&#10;        if isinstance(relates_to_node_id, NodeID):&#10;            self._graph.add_edge(&#10;                u_of_edge=node_id,&#10;                v_of_edge=relates_to_node_id,&#10;                data=dict(&#10;                    title=&#34;&#34;,&#10;                    content=relation_content,&#10;                    ),&#10;                metadata=dict(&#10;                    time=str(self._get_timestamp()),&#10;                    type=_EDGE,&#10;                    style=relation_style.strip('_'),&#10;                    ),&#10;                )&#10;        &#10;        return node_id&#10;    &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                               new_chapter                              ##&#10;    ##------------------------------------------------------------------------##&#10;    def new_chapter(self, &#10;                    title:str,&#10;                    style:str=&#34;default&#34;, &#10;                    content:Any=None) -> None:&#10;        &#34;&#34;&#34; Create new chapter, thus partitioning the log-graph in &#10;            vertical manner.&#10;&#10;        :param title: Title of the chapter displayed in ll_logger_app.&#10;        :param content: Content to be displayed in the llm_logger_app, &#10;            defaults to None&#10;        &#34;&#34;&#34;&#10;        # get new node id&#10;        self.__chapter_counter = self.__chapter_counter + 1&#10;        chapter_id = ChapterID(self.__chapter_counter)&#10;        &#10;        # add node&#10;        self._graph.add_node(&#10;            node_for_adding = chapter_id,&#10;            data=dict(&#10;                title=title,&#10;                content=content),&#10;            metadata=dict(&#10;                time=str(self._get_timestamp()),&#10;                type=_CHAPTER,&#10;                style = style.strip('_'),&#10;                ),&#10;            )&#10;    &#10;    &#10;    ##------------------------------------------------------------------------##&#10;    ##                                  report                                ##&#10;    ##------------------------------------------------------------------------##&#10;    def report(self):&#10;        chapter_ids_with_node_ids = \&#10;            get_chapter_ids_with_node_ids(graph=self._graph)&#10;        &#10;        for chapter_id, node_ids in chapter_ids_with_node_ids.items():&#10;            print(f&#34;ChapterID = '{chapter_id}'&#34;)&#10;            for node_id in node_ids:&#10;                print(f&#34;   NodeID = '{node_id}'&#34;)&#10;        &#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   save                                 ##&#10;    ##------------------------------------------------------------------------##&#10;    def save(self, &#10;            path:str=None, &#10;            filename:str=None, &#10;            format=&#34;gml&#34;, &#10;            **kwargs,&#10;        ) -> None:&#10;        &#10;        # parh&#10;        if isinstance(path, type(None)):&#10;            if isinstance(self.path, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'path' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                path = self.path&#10;        else:&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;            if not path.exists():&#10;                raise RuntimeError(&#10;                    f&#34;path='{str(path)}', does not exist! use &#34;\&#10;                    f&#34;kwargs['create_path']=True to create folder structure.&#34;)&#10;        # filename&#10;        if isinstance(filename, type(None)):&#10;            if isinstance(self.filename, type(None)):&#10;                raise RuntimeError(&#10;                    f&#34;'filename' parameter is required if not provided when &#34;\&#10;                    f&#34;LLMLogger is created!&#34;)&#10;            else:&#10;                filename = self.filename&#10;        &#10;        def default_stringizer(value:Any) -> str:&#10;            import re&#10;            if isinstance(value, type(None)):&#10;                return &#34;&#34;&#10;            if isinstance(value, NodeID):&#10;                return str(value)&#10;            if isinstance(value, ChapterID):&#10;                return str(value)&#10;            if isinstance(value, list):&#10;                return str(value)&#10;            if isinstance(value, str):&#10;                return value&#10;            raise ValueError(&#10;                f&#34;default_stringizer undefined conversion for &#34;\&#10;                f&#34;type(value)='{type(value)}'!&#34;)&#10;            &#10;        # save&#10;        if str(format).lower() == &#34;gml&#34;:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;        elif str(format).lower() == &#34;dot&#34;:&#10;            nx.write_dot(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.dot&#34;),&#10;            )&#10;        else:&#10;            nx.write_gml(&#10;                G=self._graph, &#10;                path=pl.Path(path, str(filename)+&#34;.gml&#34;),&#10;                stringizer=kwargs.get(&#34;stringizer&#34;, default_stringizer),&#10;            )&#10;            raise TypeError(&#10;                f&#34;Format='{format}', but valid formats=['gml', 'dot']! The graph &#34;\&#10;                f&#34;was saved as {str(pl.Path(path, str(filename)+'.gml'))} &#34;\&#10;                f&#34;to prevent data-loss.&#34;)&#10;&#10;&#10;    ##------------------------------------------------------------------------##&#10;    ##                                   load           "
    ]
    metadata [
      time "1717076082.428663"
      type "NODE_"
      column "A"
      style "decision"
      stack 0
      chapter_id "CHAP_000003"
    ]
  ]
  node [
    id 22
    label "NODE_000020"
    data [
      title ""
      content "&#10;import pathlib as pl&#10;from typing import Any, Literal&#10;import networkx as nx&#10;import datetime as dt&#10;import numpy as np&#10;import copy&#10;import io&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    import sys&#10;    import os&#10;    import pathlib as pl&#10;    project_root = pl.Path(os.getcwd()).absolute()&#10;    try:&#10;        sys.path.index(project_root)&#10;    except ValueError:&#10;        sys.path.append(project_root)&#10;    project_root_in_sys = sys.path[sys.path.index(project_root)]&#10;    print(f&#34;TESTING: add '{project_root_in_sys}' to PYTHONPATH&#34;)&#10;&#10;try:&#10;    from utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from utils.chapters import get_chapter_ids_with_node_ids&#10;except ImportError:&#10;    from llm_logger_src.utils.ids import NodeID, ChapterID, _NODE, _CHAPTER, \&#10;        _EDGE&#10;    from llm_logger_src.utils.chapters import get_chapter_ids_with_node_ids&#10;&#10;&#10;################################################################################&#10;##                                 llm_logger                                 ##&#10;################################################################################&#10;class LLMLogger:&#10;    &#10;    def __init__(self,&#10;        path:pl.Path=None,&#10;        filename:str=None,&#10;        **kwargs:Literal[&#34;create_path&#34;],&#10;        ):&#10;        &#10;        # sanity check&#10;        if not isinstance(path, type(None)):&#10;            path = pl.Path(path).resolve()&#10;            if kwargs.get(&#34;create_path&#34;, False):&#10;                os.makedirs(path, exist_ok=True)&#10;       "
    ]
    metadata [
      time "1717076082.428818"
      type "NODE_"
      column "B"
      style "success"
      stack 1
      chapter_id "CHAP_000003"
    ]
  ]
  edge [
    source 1
    target 2
    data [
      title ""
      content ""
    ]
    metadata [
      time "1717076082.42579"
      type "EDGE_"
      style "default"
    ]
  ]
  edge [
    source 1
    target 8
    data [
      title ""
      content ""
    ]
    metadata [
      time "1717076082.42667"
      type "EDGE_"
      style "default"
    ]
  ]
  edge [
    source 1
    target 10
    data [
      title ""
      content ""
    ]
    metadata [
      time "1717076082.426961"
      type "EDGE_"
      style "default"
    ]
  ]
  edge [
    source 1
    target 13
    data [
      title ""
      content ""
    ]
    metadata [
      time "1717076082.427397"
      type "EDGE_"
      style "default"
    ]
  ]
  edge [
    source 2
    target 5
    data [
      title ""
      content ""
    ]
    metadata [
      time "1717076082.426244"
      type "EDGE_"
      style "default"
    ]
  ]
  edge [
    source 4
    target 6
    data [
      title ""
      content ""
    ]
    metadata [
      time "1717076082.426427"
      type "EDGE_"
      style "default"
    ]
  ]
  edge [
    source 4
    target 21
    data [
      title ""
      content ""
    ]
    metadata [
      time "1717076082.428684"
      type "EDGE_"
      style "default"
    ]
  ]
  edge [
    source 9
    target 15
    data [
      title ""
      content ""
    ]
    metadata [
      time "1717076082.427711"
      type "EDGE_"
      style "default"
    ]
  ]
  edge [
    source 10
    target 11
    data [
      title ""
      content ""
    ]
    metadata [
      time "1717076082.427175"
      type "EDGE_"
      style "default"
    ]
  ]
  edge [
    source 10
    target 17
    data [
      title ""
      content ""
    ]
    metadata [
      time "1717076082.428071"
      type "EDGE_"
      style "default"
    ]
  ]
  edge [
    source 16
    target 18
    data [
      title ""
      content ""
    ]
    metadata [
      time "1717076082.428235"
      type "EDGE_"
      style "default"
    ]
  ]
]
